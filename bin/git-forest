#!/usr/bin/perl
#
#	git-森林
#	text-based tree visualisation
#	Copyright © Jan Engelhardt <jengelh [at] medozas de>, 2008
#
#	This program is free software; you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation; either version 2 or 3 of the license.
#
use strict;

use Getopt::Long;
use encoding "utf8";
use Git::Class::Cmd;

sub git { Git::Class::Cmd->new }

my $Pretty_fmt    = "format:%s";
my $Show_all      = 1;
my $Show_rebase   = 1;
my $Style         = 1;
my $Subvine_depth = 2;
my $With_sha      = 1;

main();

sub main {
    Getopt::Long::Configure( qw(bundling pass_through) );
    GetOptions(
        "all"       => \$Show_all,
        "no-rebase" => sub { $Show_rebase = 0; },
        "a"         => sub { $Pretty_fmt = "format:\e[1;30m(\e[0;32m%an\e[1;30m)\e[0m %s"; },    # ]]]]
        "pretty=s"  => \$Pretty_fmt,
        "svdepth=i" => \$Subvine_depth,
        "style=i"   => \$Style,
        "sha"       => \$With_sha,
    );
    ++$Subvine_depth;
    die "If you use --pretty, it must be in the form of --pretty=format:" if substr( $Pretty_fmt, 0, 7 ) ne "format:";
    $Pretty_fmt = substr( $Pretty_fmt, 7 );
    while ( $Pretty_fmt =~ /\%./g ) {
        die "Cannot use \%b, \%n or \%x0a in --pretty=format:" if $& eq '%b' or $& eq '%n' or ( $& . $' ) =~ /^\%x0a/i;
    }

    #
    # Give --all back. And add HEAD to include commits
    # in the rev list that belong to a detached HEAD.
    #
    unshift( @ARGV, "--all", "HEAD" ) if $Show_all;

    process();
}

sub process {
    my ( @vine );
    my $refs = get_refs();
    my @shas = git()->log( "--date-order", "--pretty=format:{%H}{%h}{%P}$Pretty_fmt", @ARGV );

    for my $i ( 0 .. $#shas ) {
        my $line = $shas[$i];
        last if !defined $line;

        my @next_sha = @shas[ $i .. $i + $Subvine_depth ];

        my ( $sha, $mini_sha, $parents, $msg ) = ( $line =~ /^\{(.*?)\}\{(.*?)\}\{(.*?)\}(.*)/s );
        @next_sha = map { ( $_ ) = /^\{(.*?)\}/ } @next_sha;
        my @parents = split " ", $parents;

        my $commit = '';

        $commit .= vine_branch( \@vine, $sha );

        my $ra = vine_commit( \@vine, $sha, \@parents );
        $commit .= graph_lines( $refs, $sha, $ra );

        $msg .= "──($mini_sha)" if $With_sha;
        $commit .= $msg . "\n";

        $commit .= vine_merge( \@vine, $sha, \@next_sha, \@parents );

        print $commit;
    }
}

sub graph_lines {
    my ( $refs, $sha, $ra ) = @_;

    return vis_post( vis_commit( $ra, " " ) ) if !exists $refs->{$sha};

    return vis_post( vis_commit( $ra ), "m" ) . ref_print( $refs->{$sha} )
}

sub get_refs {
    my @commits = git()->git( "show-ref" );

    my $ret = {};

    for my $ln ( @commits ) {
        next if !$ln;

        my ( $sha, $name ) = ( $ln =~ /^(\S+)\s+(.*)/s );
        $ret->{$sha} = [] if !exists $ret->{$sha};
        push @{ $ret->{$sha} }, $name;
        next if $name !~ m{^refs/tags/};

        my $sub_sha = git()->log( "-1", "--pretty=format:%H", $name );
        next if $sha eq $sub_sha;
        push @{ $ret->{$sub_sha} }, $name;
    }

    my $rebase = 1 if -e git()->_cwd . "/rebase-merge/git-rebase-todo" and $Show_rebase;
    if ( $rebase ) {
        if ( open my $act_fh, git()->_cwd . "/rebase-merge/git-rebase-todo" ) {
            my ( $curr ) = ( <$act_fh> =~ /^\S+\s+(\S+)/ );
            $curr = git()->git( "rev-parse", $curr );
            chomp $curr;
            unshift @{ $ret->{$curr} }, "rebase/next";
            close $act_fh;
        }

        #		chomp(my $up   = $Repo->command("rev-parse", "rebase-merge/upstream"));
        chomp( my $onto = git()->git( "rev-parse", "rebase-merge/onto" ) );
        chomp( my $old  = git()->git( "rev-parse", "rebase-merge/head" ) );

        #		unshift(@{$ret->{$up}}, "rebase/upstream");
        unshift @{ $ret->{$onto} }, "rebase/onto";
        unshift @{ $ret->{$old} },  "rebase/saved-HEAD";
    }

    my $head = git()->git( "rev-parse", "HEAD" );
    chomp $head;
    unshift @{ $ret->{$head} }, "rebase/new" if $rebase;
    unshift @{ $ret->{$head} }, "HEAD";

    return $ret;
}

#
# ref_print - print a ref with color
# @s:	ref name
#
sub ref_print {
    my $out = '';

    for my $symbol ( @{ shift @_ } ) {
        $out .= "[";
        if ( $symbol eq "HEAD" || $symbol =~ m{^rebase/} ) {
            $out .= $symbol;
        }
        elsif ( $symbol =~ m{^refs/remotes/([^/]+)/(.*)}s ) {
            $out .= "remotes/$1/$2";
        }
        elsif ( $symbol =~ m{^refs/heads/(.*)}s ) {
            $out .= $1;
        }
        elsif ( $symbol =~ m{^refs/tags/(.*)}s ) {
            $out .= $1;
        }
        elsif ( $symbol =~ m{^refs/(.*)}s ) {
            $out .= $1;
        }
        $out .= "]──";
    }

    return $out;
}

#
# vine_branch -
# @vine:	column array containing the expected parent IDs
# @rev:		commit ID
#
# Draws the branching vine matrix between a commit K and K^ (@rev).
#
sub vine_branch {
    my ( $vine, $rev ) = @_;
    my $idx;

    my ( $matched, $master ) = ( 0, 0 );
    my $ret;

    # Transform array into string
    for ( $idx = 0 ; $idx <= $#$vine ; ++$idx ) {
        if ( !defined( $vine->[$idx] ) ) {
            $ret .= " ";
            next;
        }
        elsif ( $vine->[$idx] ne $rev ) {
            $ret .= "I";
            next;
        }
        if ( !$master and $idx % 2 == 0 ) {
            $ret .= "S";
            $master = 1;
        }
        else {
            $ret .= "s";
            $vine->[$idx] = undef;
        }
        ++$matched;
    }

    return if $matched < 2;

    remove_trailing_blanks( $vine );
    return vis_post( vis_fan( $ret, "branch" ) ) . "\n";
}

#
# vine_commit -
# @vine:	column array containing the expected IDs
# @rev:		commit ID
# @parents:	array of parent IDs
#
sub vine_commit {
    my ( $vine, $rev, $parents ) = @_;
    my $ret;

    for ( my $i = 0 ; $i <= $#$vine ; ++$i ) {
        if ( !defined( $vine->[$i] ) ) {
            $ret .= " ";
        }
        elsif ( $vine->[$i] eq $rev ) {
            $ret .= "C";
        }
        else {
            $ret .= "I";
        }
    }

    if ( $ret !~ /C/ ) {

        # Not having produced a C before means this is a tip
        my $i;
        for ( $i = round_down2( $#$vine ) ; $i >= 0 ; $i -= 2 ) {
            next if substr( $ret, $i, 1 ) ne " ";

            substr( $ret, $i, 1 ) = "t";
            $vine->[$i] = $rev;
            last;
        }
        if ( $i < 0 ) {
            if ( scalar( @$vine ) % 2 != 0 ) {
                push @$vine, undef;
                $ret .= " ";
            }
            $ret .= "t";
            push @$vine, $rev;
        }
    }

    remove_trailing_blanks( $vine );

    # tree root
    $ret =~ tr/C/r/ if !@$parents;

    return $ret;
}

#
# vine_merge -
# @vine:	column array containing the expected parent IDs
# @rev:		commit ID
# @next_rev:	next commit ID in the revision list
# @parents:	parent IDs of @rev
#
# Draws the merging vine matrix between a commit K (@rev) and K^ (@parents).
#
sub vine_merge {
    my ( $vine, $rev, $next_rev, $parents ) = @_;
    my $orig_vine = -1;
    my @slot;
    my ( $ret, $max );

    for ( my $i = 0 ; $i <= $#$vine ; ++$i ) {
        next if $vine->[$i] ne $rev;

        $orig_vine = $i;
        last;
    }

    die "vine_commit() did not add this vine." if $orig_vine == -1;

    if ( @$parents <= 1 ) {

        #
        # A single parent does not need a visual. Update and return.
        #
        $vine->[$orig_vine] = $parents->[0];
        remove_trailing_blanks( $vine );
        return;
    }

    #
    # Put previously seen branches in the vine subcolumns
    # Need to keep at least one parent for the slot algorithm below.
    #
    for ( my $j = 0 ; $j <= $#$parents and $#$parents > 0 ; ++$j ) {
        for ( my $idx = 0 ; $idx <= $#$vine ; ++$idx ) {
            next if $vine->[$idx] ne $parents->[$j] or !grep { my $z = $vine->[$idx]; /^\Q$z\E$/ } @$next_rev;
            die "Should not really happen" if $idx == $orig_vine;
            if ( $idx < $orig_vine ) {
                my $p = $idx + 1;
                $p = $idx - 1 if defined $vine->[$p];
                last if defined $vine->[$p];
                $vine->[$p] = $parents->[$j];
                str_expand( \$ret, $p + 1 );
                substr( $ret, $p, 1 ) = "s";
            }
            else {
                my $p = $idx - 1;
                $p = $idx + 1 if defined $vine->[$p] or $p < 0;
                last if defined $vine->[$p];
                $vine->[$p] = $parents->[$j];
                str_expand( \$ret, $p + 1 );
                substr( $ret, $p, 1 ) = "s";
            }
            splice @$parents, $j, 1;
            --$j;    # outer loop
            last;    # inner loop
        }
    }

    #
    # Find some good spots to split out into and record columns
    # that will be used soon in the @slot list.
    #
    push( @slot, $orig_vine );
    my $parent = 0;

    for ( my $seeker = 2 ; $parent < $#$parents and $seeker < 2 + $#$vine ; ++$seeker ) {
        my $idx = ( $seeker % 2 == 0 ) ? -1 : 1;
        $idx *= int( $seeker / 2 );
        $idx *= 2;
        $idx += $orig_vine;

        if ( $idx >= 0 and $idx <= $#$vine and !defined $vine->[$idx] ) {
            push @slot, $idx;
            $vine->[$idx] = "0" x 40;
            ++$parent;
        }
    }
    for ( my $idx = $orig_vine + 2 ; $parent < $#$parents ; $idx += 2 ) {
        if ( !defined( $vine->[$idx] ) ) {
            push @slot, $idx;
            ++$parent;
        }
    }

    die "Serious internal problem" if @slot != @$parents;

    @slot = sort { $a <=> $b } @slot;
    $max = @$vine + 2 * @slot;

    for ( my $i = 0 ; $i < $max ; ++$i ) {
        str_expand( \$ret, $i + 1 );
        if ( $#slot >= 0 and $i == $slot[0] ) {
            shift @slot;
            $vine->[$i] = shift @$parents;
            substr( $ret, $i, 1 ) = ( $i == $orig_vine ) ? "S" : "s";
        }
        elsif ( substr( $ret, $i, 1 ) eq "s" ) {
            ;    # keep existing fanouts
        }
        elsif ( defined $vine->[$i] ) {
            substr( $ret, $i, 1 ) = "I";
        }
        else {
            substr( $ret, $i, 1 ) = " ";
        }
    }

    return vis_post( vis_fan( $ret, "merge" ) ) . "\n";
}

#
# vis_* - transform control string into usable graphic
#
# To cut down on code, the three vine_* functions produce only a dumb,
# but already unambiguous, control string which needs some processing
# before it is ready for public display.
#

sub vis_commit {
    my $s = shift @_;
    my $f = shift @_;
    $s =~ s/ +$//gs;
    $s .= $f if defined $f;
    return $s;
}

sub vis_fan {
    my $s = shift @_;
    my $b = shift( @_ ) eq "branch";

    $s =~ s{s.*s}{
        $_ = $&;
        $_ =~ tr/ I/DO/;
        $_;
    }ei;

    # Transform an ODODO.. sequence into a contiguous overpass.
    $s =~ s{O[DO]+O}{"O" x length($&)}eg;

    # Do left/right edge transformation
         $s =~ s{(s.*)S(.*s)}{&vis_fan3($1, $2)}es
      || $s =~ s{(s.*)S}{&vis_fan2L($1)."B"}es
      || $s =~ s{S(.*s)}{"A".&vis_fan2R($1)}es
      || die "Should not come here";

    $s =~ tr/efg/xyz/ if $b;

    return $s;
}

sub vis_fan2L {
    my $l = shift @_;
    $l =~ s/^s/e/;
    $l =~ s/s/f/g;
    return $l;
}

sub vis_fan2R {
    my $r = shift @_;
    $r =~ s/s$/g/;
    $r =~ s/s/f/g;
    return $r;
}

sub vis_fan3 {
    my ( $l, $r ) = @_;
    $l =~ s/^s/e/;
    $l =~ s/s/f/g;
    $r =~ s/s$/g/;
    $r =~ s/s/f/g;
    return "${l}K$r";
}

sub vis_xfrm {

    # A: branch to right
    # B: branch to right
    # C: commit
    # D:
    # e: merge visual left (╔)
    # f: merge visual center (╦)
    # g: merge visual right (╗)
    # I: straight line (║)
    # K: branch visual split (╬)
    # m: single line (─)
    # O: overpass (≡)
    # r: root (╙)
    # t: tip (╓)
    # x: branch visual left (╚)
    # y: branch visual center (╩)
    # z: branch visual right (╝)
    # *: filler

    my $s   = shift @_;
    my $spc = shift @_;
    if ( $spc ) {
        $s =~ s{[Ctr].*}{
            $_ = $&;
            $_ =~ s{ }{\*}g;
            $_;
        }esg;
    }

    $s =~ tr/ABCD.efg.IKO.mrt.xyz/├┤├─.┌┬┐.│┼≡.─└┌.└┴┘/ if $Style == 1;
    $s =~ tr/ABCD.efg.IKO.mrt.xyz/╠╣╟═.╔╦╗.║╬═.─╙╓.╚╩╝/ if $Style == 2;
    $s =~ tr/ABCD.efg.IKO.mrt.xyz/├┤├─.╭┬╮.│┼≡.─└┌.╰┴╯/ if $Style == 10;
    $s =~ tr/ABCD.efg.IKO.mrt.xyz/┣┫┣━.┏┳┓.┃╋☰.━┗┏.┗┻┛/ if $Style == 15;

    return $s;
}

#
# vis_post - post-process/transform vine graphic
# Apply user-specific style transformation.
#
sub vis_post {
    my $s = shift @_;
    my $f = shift @_;

    $s = vis_xfrm( $s, defined $f );
    $f =~ s/^([^\x1b]+)/vis_xfrm($1)/e;
    $f =~ s/(\x1b.*?m)([^\x1b]+)/$1.vis_xfrm($2)/eg;
    if ( defined $f ) {
        $s =~ s/\*/$f/g;
        $s .= $f;
    }

    return $s;
}

sub remove_trailing_blanks {
    my $a = shift @_;

    while ( @$a > 0 and !defined $a->[$#$a] ) {
        pop( @$a );
    }
}

sub round_down2 {
    my $i = shift @_;
    return $i if $i < 0;
    return $i & ~1;
}

sub str_expand {
    my $r = shift @_;
    my $l = shift @_;

    $$r .= " " x ( $l - length $$r ) if length $$r < $l;
}
