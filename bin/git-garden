#!/usr/bin/perl

=head1 SYNOPSIS

    perl bin/git-garden --help

    perl bin/git-garden --git_dir t/repos/test -t gnuplot
    firefox simple.png

    perl bin/git-garden --git_dir t/repos/test
    firefox simple.html

=cut

use strict;
use warnings;
use 5.010;

use lib ( 'lib', '../lib' );
use Git::Class::Cmd;
use encoding "utf8";
use GraphViz;
use File::Slurp 'write_file';
use QuickPlot;
use List::Util 'max';
use Getopt::Long::Descriptive;
use JSON 'to_json';

$|++;

sub git { Git::Class::Cmd->new }

main();

sub main {
    my ( $opt, $usage ) = describe_options(
        'git-garden %o',    #
        [],
        [ 'git_dir|d=s', "path to the git repository you want to graph, can be either to the checkout, the .git dir, or even any renamed git metadata dir. Default: .", { default => '.' } ],
        [ 'dump_type|t=s', "Format in which to dump the generated data. ( html, gnuplot ) Default: html", { default => 'html' } ],
        [],
        [ 'help|h', "print usage message and exit" ],
    );
    print( $usage->text ), exit if $opt->help;

    my $commits = prepare_commits( $opt->git_dir );

    my $grid = process( $commits );

    htmlplot_grid( $grid, "simple" ) if $opt->dump_type eq 'html';
    gnuplot_grid( $grid, "simple" ) if $opt->dump_type eq 'gnuplot';
}

sub parse_commit {
    my ( $line ) = @_;

    my ( $sha, $mini_sha, $parents, $msg ) = ( $line =~ /^\{(.*?)\}\{(.*?)\}\{(.*?)\}(.*)/s );

    my %commit = (
        sha      => $sha,
        mini_sha => $mini_sha,
        parents  => [ split " ", $parents ],
        msg      => $msg
    );

    return \%commit;
}

sub htmlplot_grid {
    my ( $grid, $file ) = @_;

    my @rows;
    for my $row ( @{$grid} ) {
        next if !$row;
        push @rows, qq|
            <tr>
                <td id="graph_$row->{commit}{sha}"></td>
                <td>$row->{commit}{sha}</td>
            </tr>
        |;
    }
    my $rows = join "\n", @rows;

    delete $_->{commit}{parents} for @{$grid};
    my $json = to_json( $grid );

    my $js = graphlog_js();

    my $html = qq|
<!DOCTYPE html>

<html>
<head>
    <script type="text/javascript" src="http://code.jquery.com/jquery-latest.min.js"></script>
    <script type="text/javascript" src="http://github.com/DmitryBaranovskiy/raphael/raw/master/raphael.js"></script>
    <script type="text/javascript">
        <!--
            $js

            var commit_rows = jQuery.makeArray( $json );

            \$(document).ready(function() {
                do_graphs();
            });
        -->
    </script>
</head>

<body>
    <table style="border-collapse:collapse; border-spacing: 0px;">
        <tr>
            <th style="width:200px;">Graph</td>
            <th>SHA</th>
        </tr>
        $rows
    </table>
</body>
    |;

    write_file( "$file.html", $html );

    return;
}

sub gnuplot_grid {
    my ( $grid, $file ) = @_;

    my $chart = QuickPlot->new( file => $file );
    my $max_col = 0;

    say "adding rows";
    for my $row ( @{$grid} ) {
        next if !$row;
        print ".";

        my $merge_branch_column_index;

        for my $col ( @{ $row->{columns} } ) {
            next if !$col;

            $chart->add( "⎕", $col->{index}, $row->{index} ) if $col->{visuals}{commit};
            $chart->add( "│", $col->{index}, $row->{index} ) if $col->{visuals}{expects_commit};

            $chart->add( "┐", $col->{index}, $row->{index} ) if $col->{visuals}{merge_point};
            $chart->add( "┘", $col->{index}, $row->{index} ) if $col->{visuals}{branch_point};

            $merge_branch_column_index = $col->{index}
              if ( !$merge_branch_column_index or $col->{index} > $merge_branch_column_index ) and $col->{visuals}{merge_point}
              or $col->{visuals}{branch_point};

            $max_col = $col->{index} if $col->{index} > $max_col;
        }

        next if !defined $merge_branch_column_index;

        my $commit_column_index = $row->{commit_column_index};

        for my $connect_index ( $commit_column_index + 1 .. $merge_branch_column_index - 1 ) {
            $chart->add( "─", $connect_index, $row->{index} );
        }
    }

    for my $row ( @{$grid} ) {
        next if !$row;
        $chart->add( $row->{commit}{mini_sha}, $max_col + 5, $row->{index} );
        $chart->add( " ",                      $max_col + 8, $row->{index} );
    }

    say "rendering";
    $chart->render;

    return;

}

sub process {
    my ( $commits ) = @_;

    say "building grid";
    my @grid;
    for my $commit ( @{$commits} ) {
        my $prev_row = $grid[$#grid] || { columns => [] };
        my $row = { index => $#grid + 1, commit => $commit, columns => [], parents_to_match => scalar( @{ $commit->{parents} } ) };
        push @grid, $row;

        mark_commit_column( $row, $prev_row, $commit );

        mark_expecting_column( $row, $prev_row, $commit, $_ ) for @{ $commit->{parents} };

        mark_expectations_and_branch_points( $prev_row, $row );
    }

    return \@grid;
}

sub get_refs {
    my @commits = git()->git( "show-ref", "-d" );

    my %refs;

    for my $ln ( @commits ) {
        next if !$ln;

        my ( $sha, $name ) = ( $ln =~ /^(\S+)\s+(.*)/s );
        $name =~ s/\^\{\}//;
        $refs{$sha} = [] if !exists $refs{$sha};
        push @{ $refs{$sha} }, $name;
    }

    my $head = git()->git( "rev-parse", "HEAD" );
    chomp $head;
    unshift @{ $refs{$head} }, "HEAD";

    return \%refs;
}

sub prepare_commits {
    my ( $dir ) = @_;

    my ( $refs, $commits, $commit_count ) = get_git_meta_data( $dir );

    $commits->[$_]->{index} = $_ for 0 .. $#{$commits};

    my %commits = map { $_->{sha} => $_ } @{$commits};
    for my $commit ( @{$commits} ) {
        my @parents = map $commits{$_}, @{ $commit->{parents} };
        @parents = sort { $a->{index} <=> $b->{index} } @parents;
        $commit->{parents}     = \@parents;
        $commit->{refs}        = $refs->{ $commit->{sha} } || [];
        $commit->{merge_depth} = -1;
    }

    for my $commit ( @{$commits} ) {
        my @parents = @{ $commit->{parents} };
        next if @parents < 2;

        $_->{merge_depth} = find_merge_depth( $_, $commit_count ) for @parents;
        @parents = sort { $a->{merge_depth} <=> $b->{merge_depth} } @parents;
        $commit->{parents} = \@parents;
    }

    return $commits;
}

sub get_real_git_dir {
    my ( $dir ) = @_;

    return $dir           if -d $dir . "/refs/heads";
    return $dir . "/.git" if -d $dir . "/.git/refs/heads";
    return $dir . "/git"  if -d $dir . "/git/refs/heads";
    die "could not identify git meta-data directory, expecting a path to something that contains the dir refs/heads";
}

sub get_git_meta_data {
    my ( $dir ) = @_;

    my $real_dir = get_real_git_dir( $dir );

    $ENV{GIT_DIR} = $real_dir;

    say "getting refs";
    my $refs = get_refs();

    say "getting commits";
    my @commits = map parse_commit( $_ ), git()->log( "--date-order", "--pretty=format:{%H}{%h}{%P}%s", "--all", "HEAD" );

    delete $ENV{GIT_DIR};

    return ( $refs, \@commits, scalar @commits );
}

sub find_merge_depth {
    my ( $commit, $commit_count ) = @_;

    my $depth = 0;

    while ( $commit ) {
        return $depth if @{ $commit->{parents} } > 1;

        $depth++;
        $commit = $commit->{parents}[0];
    }

    return $commit_count;
}

sub mark_expectations_and_branch_points {
    my ( $prev_row, $row ) = @_;

    my $columns      = $row->{columns};
    my $prev_columns = $prev_row->{columns};

    for my $prev_col ( @{$prev_columns} ) {
        next if !$prev_col;
        next if !$prev_col->{expected_sha};

        if ( $prev_col->{expected_sha} ne $row->{commit}{sha} ) {
            add_visual_to_column( $row, $prev_col->{index}, "expects_commit" );
            $row->{columns}[ $prev_col->{index} ]{expected_sha} = $prev_col->{expected_sha};
        }
        elsif ( $row->{commit_column_index} != $prev_col->{index} ) {
            add_visual_to_column( $row, $prev_col->{index}, "branch_point" );
        }
    }

    return;
}

sub mark_expecting_column {
    my ( $row, $prev_row, $commit, $parent ) = @_;

    my $expecting_column_index = find_column_index_for_expected_parent( $row, $prev_row, $parent );
    add_visual_to_column( $row, $expecting_column_index, 'merge_point' ) if $expecting_column_index != $row->{commit_column_index};
    $row->{columns}[$expecting_column_index]{expected_sha} = $parent->{sha};

    $row->{parents_to_match}--;

    return;
}

sub find_column_index_for_expected_parent {
    my ( $row, $prev_row, $parent ) = @_;

    my $columns                         = $row->{columns};
    my $commit_column_index             = $row->{commit_column_index};
    my $parents_with_higher_merge_depth = grep { $_->{merge_depth} > $parent->{merge_depth} } @{ $row->{commit}{parents} };

    my @expecting_cols = grep col_expects_this_parent( $_, $parent ), @{ $prev_row->{columns} };
    return $expecting_cols[0]{index} if @expecting_cols and $row->{parents_to_match} > 1 and $expecting_cols[0]{index} >= $commit_column_index and !$parents_with_higher_merge_depth;

    return $commit_column_index if $columns->[$commit_column_index] and !$columns->[$commit_column_index]{expected_sha} and ( !@{ $parent->{refs} } or $row->{parents_to_match} == 1 );

    return $expecting_cols[0]{index} if @expecting_cols and $expecting_cols[0]{index} >= $commit_column_index;

    my $prev_cols = $prev_row->{columns};
    my $max_look = max( $#{$columns}, $#{$prev_cols} );

    for my $column_index ( 0 .. $max_look ) {
        my $column = $columns->[$column_index];

        next if $prev_cols->[$column_index] and $prev_cols->[$column_index]{expected_sha} and $prev_cols->[$column_index]{expected_sha} ne $parent->{sha};
        next if $column_index <= $commit_column_index;

        return $column_index if !$column;
        return $column_index if !$column->{expected_sha};
    }

    return $max_look + 1;
}

sub col_expects_this_parent {
    my ( $col, $parent ) = @_;

    return if !$col;
    return if !$col->{expected_sha};
    return if $col->{expected_sha} ne $parent->{sha};

    return 1;
}

sub mark_commit_column {
    my ( $row, $prev_row, $commit ) = @_;

    $row->{commit_column_index} = find_commit_column_index( $prev_row, $row, $commit );

    add_visual_to_column( $row, $row->{commit_column_index}, 'commit' );
    add_visual_to_column( $row, $row->{commit_column_index}, 'merge' ) if @{ $commit->{parents} } > 1;

    return;
}

sub add_visual_to_column {
    my ( $row, $column_index, $visual ) = @_;

    my $commit_col = $row->{columns}[$column_index] ||= { index => $column_index };
    $commit_col->{visuals}{$visual} = 1;

    return;
}

sub find_commit_column_index {
    my ( $prev_row, $row, $commit ) = @_;

    my $column_index = find_expected_column_index_for_commit( $prev_row, $row->{commit} );
    $column_index //= find_next_empty_column_index( $prev_row );

    return $column_index;
}

sub find_expected_column_index_for_commit {
    my ( $prev_row, $commit ) = @_;

    for my $column ( @{ $prev_row->{columns} } ) {
        next if !$column;
        next if !$column->{expected_sha};
        next if $column->{expected_sha} ne $commit->{sha};

        return $column->{index};
    }

    return;
}

sub find_next_empty_column_index {
    my ( $prev_row ) = @_;

    my $columns = $prev_row->{columns};
    for my $column_index ( 0 .. $#{$columns} ) {
        next if $columns->[$column_index];
        return $column_index;
    }

    return $#{$columns} + 1;
}

########## GRAPHVIZ ###################################

sub graphviz_commits {
    my ( $commits ) = @_;

    my $g = GraphViz->new( edge => { dir => 'back' } );

    $g->add_node( $_->{mini_sha} ) for @{$commits};

    for my $commit ( @{$commits} ) {
        $g->add_edge( $commit->{mini_sha} => $_->{mini_sha} ) for @{ $commit->{parents} };
    }

    write_file 'git.png', { binmode => ':raw' }, $g->as_png;

    return;
}

sub graphlog_js {
q|
var colors = Array();
var max_column = 0;
var min_size_limit = 9999;

function do_graphs() {
    fill_colors();
    var graphs = Array();
    $(commit_rows).each(function () {
        if ( !this.columns ) return;
        if ( this.columns.length > max_column ) max_column = this.columns.length;
        return;
    });

    $(commit_rows).each(function () {
        var r = render_canvas( 'graph_' + this.commit.sha );
        if ( r ) this.canvas = r;
        return;
    });

    $(commit_rows).each(function () {
        var commit_row = this;

        if ( !commit_row.canvas ) return;

        var canvas = commit_row.canvas;
        var commit_column_index = commit_row.commit_column_index;

        $(commit_row.columns).each(function () {
            var column = this;
            if ( !column ) return;
            if ( !column.visuals ) return;

            if ( column.visuals.commit         ) draw_commit(       canvas, column.index);
            if ( column.visuals.expects_commit ) draw_expects(      canvas, column.index);
            if ( column.visuals.merge_point    ) draw_merge_point(  canvas, column.index);
            if ( column.visuals.branch_point   ) draw_branch_point( canvas, column.index);

            if ( column.visuals.merge_point    ) draw_branch_merge_line( canvas, column.index, column.index - commit_column_index - 1 );
            if ( column.visuals.branch_point   ) draw_branch_merge_line( canvas, column.index, column.index - commit_column_index - 1 );

            return;
        });

        return;
    });

    var graph_index = graphs.length;
    while (graph_index--) {
        var graph = graphs[graph_index];
        var color_index = max_column + 1;
        while (color_index--) {
            draw_expects(graph, color_index);
            draw_commit(graph, color_index);
            draw_merge_point(graph, color_index);
            draw_branch_point(graph, color_index);
        }
    }
}

function draw_expects(r, column) {
    var cell = get_graph_cell(r, column);

    var path = r.path("M0 0L0 {0}", r.height);
    transform_to_cell(path, cell);

    return;
}

function draw_commit(r, column) {
    var cell = get_graph_cell(r, column);

    var circle = r.circle(0, r.height / 2, min_size_limit / 2 * .7);
    transform_to_cell(circle, cell);

    return;
}

function draw_merge_point(r, column) {
    var cell = get_graph_cell(r, column);

    var center_offset = min_size_limit / 3;
    var merge_point = r.path(
        "M{0} {1}L{2} {3}L{4} {5}L{6} {7}", //
        -1 * cell.width / 2,r.height / 2, //
        -1 * center_offset, r.height / 2, //
        0,                  r.height / 2 + center_offset, //
        0,                  r.height //
    );
    transform_to_cell(merge_point, cell);

    return;
}

function draw_branch_point(r, column) {
    var cell = get_graph_cell(r, column);

    var center_offset = min_size_limit / 3;
    var branch_point = r.path(
        "M{0} {1}L{2} {3}L{4} {5}L{6} {7}", //
        0,                  0, //
        0,                  r.height / 2 - center_offset, //
        -1 * center_offset, r.height / 2, //
        -1 * cell.width / 2,r.height / 2 //
    );
    transform_to_cell(branch_point, cell);

    return;
}

function draw_branch_merge_line(r, column, line_length) {
    if ( !line_length ) return;
    var cell = get_graph_cell(r, column);

    var center_offset = min_size_limit / 3;
    var branch_merge_line = r.path(
        "M{0} {1}L{2} {3}", //
        0 - cell.width * line_length, r.height / 2, //
        0,                            r.height / 2
    );
    branch_merge_line.translate(cell.width / -2, 0);

    transform_to_cell(branch_merge_line, cell);

    return;
}

function transform_to_cell(vector_obj, cell) {
    vector_obj.translate(cell.width / 2, 0);
    vector_obj.translate(cell.offset, 0);
    vector_obj.attr({
        stroke: colors[cell.column % 8]
    });

    return;
}

function get_graph_cell(r, column) {
    var width = r.width / (max_column + 1);
    var offset = width * column;
    var size_limit = width;
    if ( r.height < size_limit ) size_limit = r.height;
    return {
        size_limit: size_limit,
        width: width,
        offset: offset,
        column: column
    };
}

function fill_colors() {
    colors[0] = "#000000";
    var color_index = 7;
    while (color_index--) {
        Raphael.getColor();
        colors[color_index + 1] = Raphael.getColor();
    }
    return;
}

function render_canvas(id) {
    var target = $('#' + id);
    if ( !target.length ) return;
    var x = target.offset().left;
    var y = target.offset().top;
    var width = target.innerWidth();
    var height = target.innerHeight();

    target.css('padding', '0');
    target.css('line-height', '0');

    var r = Raphael(id, width, height);

    if ( r.height < min_size_limit ) min_size_limit = r.height;
    if ( r.width / max_column + 1 < min_size_limit ) min_size_limit = r.width / max_column + 1;

    return r;
}
|;
}
